---
layout: post
title: Fancy CLIs
date: 2020-06-08
comments: true
external-url:
tag: Python
---

<!-- markdownlint-disable MD004 MD009 MD014 MD024 MD040 -->

You might have seen programmers everywhere using the command line for all sorts of daily tasks. It looks kind of unfriendly and complicated, right?

How about we make things a little prettier and easier for people to use?

```python
print("Hello command line")
```

Hosted by: Harsh Deep

## Motivation

Here's an 18 minute audio recording made specially for this summer session by [Donovan Keme](https://github.com/digitalextremist), my mentor last summer who broadened my perspective on tech entirely. His open source Ruby work has been part of almost [450 million downloads](https://rubygems.org/profiles/digitalextremist), and he's very involved with the community.

This is a more somber and serious recording instead of the typical emotional pep talk, but it's important to consider in your journey after several months about learning about technology. At this point, it's the right time to start thinking about what role technology plays in the world and what purpose you want to achieve with technology.

[Recording link](https://extremist.digital/audio/126-m20210504083039-5tp5-harsh.mp3
)

Don't worry if you don't know what your purpose is right now. What this means can be different for everyone. Over the next few months, start to reflect and chart out your goals of what you want to do and the steps you want to take from there. Feel free to message any of the staff or create a forum post if you want to talk about it too.

## Getting Ready

1. Learn a bit of git on the commmand line. You can use any intro tutorial, but [this web browser one](https://learngitbranching.js.org/) looks good.

2. Go over the basics of test driven development with `pytest` in this tutorial on [the site](/testing101). Code along everything just to get an idea of why we test and how to create your workflow around tests. While I don't want all projects to have extensive tests (although it is a good habit), having even just 3-5 tests makes a huge difference.

3. Learn a few basics of how a command line works. [Here is a quick crash course](https://www.vikingcodeschool.com/web-development-basics/a-command-line-crash-course) with links to resources to learn even more. The command line is intimidating, but once you get used to it, you'll wonder how you lived without it. It's part of almost every programmer's toolbox.

## Workshop

Our goal is to make a fancy git add CLI with a nice interactive interface. We display a list of files that can be added and then have the user select. Then we provide them an option to commit the file as well.

Note: I've done this on an Ubuntu `20.04` system. Your progress won't be drastically different but you may need to adjust depending on how your OS does things. Feel free to post forum questions in case there are any problems. I used `python 3.8.5`.

### Libraries

Create a file called `requirements.txt` and fill it with this. This is a common convention in Python projects for listing all the libraries required.

```js
pyinquirer
pyfiglet
plumbum
pylint
pytest
```

Once you've saved this file, to install you just have to run (if you use `python3` to excute commands this will be `pip3`).

```bash
$ pip install -r requirements.txt
[install output]
```

The `-r` flag tells `pip` to look at `requirements.txt` and install everything in it.

Let me explain how we're using each library.

* `pyinquirer` give us fancy interactive menu interfaces
* `pyfiglet` gives us ASCII art displays
* `plumbum` gives us a way of accepting input, displaying help information and calling existing system commands
* `pylint` is for style checking
* `pytest` is for simple testing

### Get started

Create a file called `fgit.py`.

We use `cli` from the `plumbum` library to create the base template for our command line application.

```python
from plumbum import cli

class FancyGitAdd(cli.application):
    def main(self):
        print("Welcome to Fancy Git Add!")

if __name__ == "__main__":
    FancyGitAdd()

```

Now if we run this we get our starter message.

```bash
$ python fgit.py
Welcome to Fancy Git Add!
```

The reason we have a `__name__ == "__main__"` condition is because our program will be run in different ways. When running the program normally through python the condition will be true and the stuff inside will run, but in other cases it won't.

Basically, without that, our tests will not work and give a screenful of nasty errors. We haven't written any tests yet but just to sanity check.

```bash
$ pytest fgit.py
[tests pass]
```

Which will tell us everything is good and no test ran.

### Provide help

Almost every major command line program lets you ask for help using `-h` or `--help`. This is good because things can be quite confusing otherwise. Writing good help messages for users is _highly reccomended_.

Lets see what we get out of the box thanks to `plumbum`.

```bash
$ python fgit.py --help
Usage:
    fgit.py [SWITCHES]

Meta-switches:
    -h, --help         Prints this help message and quits
    --help-all         Prints help messages of all sub-commands and quits
    -v, --version      Prints the program's version and quits
```

Not a bad start. Now the first thing we can do is give our a version number. In a real program we will change the version number as we add new changes so that people know when to update.

```python
from plumbum import cli

class FancyGitAdd(cli.Application):
    VERSION = "1.3"

    def main(self):
        print("Welcome to Fancy Git Add")

if __name__ == "__main__": 
    FancyGitAdd()  
```

This gets our version number display working nicely:

```bash
$ python fgit.py --version
fgit.py 1.3
$ python fgit.py -h
fgit.py 1.3

Usage:
    fgit.py [SWITCHES]

Meta-switches:
    -h, --help         Prints this help message and quits
    --help-all         Prints help messages of all sub-commands and quits
    -v, --version      Prints the program's version and quits
```

Note: One character flags have a single dash `-` and are one letter long to be short. The longer flag is usually a word or phrase and has two dashes `-`.

## Improve the display

The text output from `print` does look nice but we want those fancy ASCII art displays. For this we're going to use `pyfiglet`

```python
from pyfiglet import Figlet

def print_banner(text):
    print(Figlet(font='slant').renderText(text))

class FancyGitAdd(cli.Application):
    VERSION = "1.3"

    def main(self):
        print_banner("Git fancy add")

if __name__ == "__main__":
    FancyGitAdd()
```

We create a function `print_banner(text)` to print our ASCII banner on our screen based on the [pyfiglet documentation](https://github.com/pwaller/pyfiglet).

In general, it's a good practice to have extracted out functions (like this one) so that we can create more layers of abstraction for readability or testing. The command line application doesn't need to bother itself with the details of _how_ we print a banner, just that it gets printed.

## Collecting a list of files

One of the most common commands we ever use in the command line is called `ls` to list all files in the current folder.

Let's try it out to get a list of 5 items I have (your system might vary but adjust accordingly)

```bash
$ ls
__pycache__  fgit.py  file3.txt  requirements.txt  test_folder
```

Lets use this as a chance to show off red-green-refactor with `pytest`.

### Red

For testing around I'm creating a folder called `test_folder` with two files `file1.txt` and `file2.txt`. I'm also adding a `file3.txt` outside the folder. You can create whatever sample files you like.

If you want to do the same thing as I am doing using `mkdir` (create directory), `cd` (change directory), and `touch` (create file or update last edited)

```bash
$ mkdir test_folder
$ touch test_folder/file1.txt test_folder/file2.txt file3.txt
$
```

The end result looks something like this: (generated via a command line program called [tree](https://linux.die.net/man/1/tree)).

```bash
$ tree
.
├── __pycache__
│   └── fgit.cpython-38-pytest-6.2.4.pyc
├── fgit.py
├── file3.txt
├── requirements.txt
└── test_folder
    ├── file1.txt
    └── file2.txt
```

Now lets come up with a function `get_files()` which will return a `List` of the files in the given directory. We write a stub for that function and write a test `test_get_files()` to test it.

```python
from pyfiglet import Figlet
from plumbum import cli

def print_banner(text):
    print(Figlet(font='slant').renderText(text))

def get_files():
    return [] # empty list for now

class FancyGitAdd(cli.Application):
    VERSION = "1.3"

    def main(self):
        print_banner("Git fancy add")
        files = get_files()

if __name__ == "__main__":
    FancyGitAdd()

### TESTS

def test_get_files():
    files = get_files()
    assert len(files) == 5
```

Which if we now test

```bash
$ pytest fgit.py
    def test_get_files():
        files = get_files()
>       assert len(files) == 5
E       assert 0 == 5
E        +  where 0 = len([])

fgit.py:39: AssertionError
```

Which is what we expect. One we implement the feature this test will become green.

### Green

Using `plumbum.cmd` we can import commands from the command line and use it within python. This import lets us import basically any existing system command so that we can use it in our program.

The first step of understanding how to process output of a command line program is just inspecting it. Here we just `print` it with a `"start"` and `"end"` to understand how the string processing is working.

```python
from pyfiglet import Figlet
from plumbum import cli
from plumbum.cmd import ls

[...]

def get_files():
    ls_output = ls()
    print("start", ls_output, "end")
    return [] # empty list for now

[...]

def test_get_files():
    files = get_files()
    assert len(files) == 5
```

and the output snippet we get is

```txt
start __pycache__
fgit.py
file3.txt
requirements.txt
test_folder
 end
```

Looks like we have to split by line and take care of some whitespace around the start and end. We can use a combo of `strip` (strip is quite common to use when dealing with string output) and `split`. Our final funcion will be

```python
def get_files():
    ls_output = ls().strip()
    print("start", ls_output, "end")
    files = ls_output.split("\n")
    return files

[...]

def test_get_files():
    files = get_files()
    assert len(files) == 5
```

Now if we run this with `pytest` it will give green.

```bash
$ pytest fgit.py
[test pass]
```

### Refactor

One we have a working test for a feature, we can refactor (improve) our code with confidence. The test cases act as a safety net.

If we run our program

```bash
$ python fgit.py
   _______ __     ____                                    __    __
  / ____(_) /_   / __/___ _____  _______  __   ____ _____/ /___/ /
 / / __/ / __/  / /_/ __ `/ __ \/ ___/ / / /  / __ `/ __  / __  /
/ /_/ / / /_   / __/ /_/ / / / / /__/ /_/ /  / /_/ / /_/ / /_/ /
\____/_/\__/  /_/  \__,_/_/ /_/\___/\__, /   \__,_/\__,_/\__,_/
                                   /____/

start __pycache__
fgit.py
file3.txt
requirements.txt
test_folder end
```

The debug output still appears. A refactor step would be removing that and just checking if the tests work again.

We update `get_files()`

```python
def get_files():
    ls_output = ls().strip()
    files = ls_output.split("\n")
    return files
```

and running tests should still give green

```bash
$ pytest fgit.py
[tests pass]
```

Our full code at this stage should be

```python
from pyfiglet import Figlet
from plumbum import cli
from plumbum.cmd import ls

def print_banner(text):
    print(Figlet(font='slant').renderText(text))

def get_files():
    ls_output = ls().strip()
    files = ls_output.split("\n")
    return files

class FancyGitAdd(cli.Application):
    VERSION = "1.3"

    def main(self):
        print_banner("Git fancy add")
        files = get_files()

if __name__ == "__main__":
    FancyGitAdd()

def test_get_files():
    files = get_files()
    assert len(files) == 5
```

Note: This is a simple test for teaching reasons. In real life you should write tests more robust since this can easily break if I have one more or one less file.

## Fancy Menu Selectors

Now we want to create a checkbox like system you can go up and down on. We use `PyInquirer` to ask. The format for checkbox questions is similar to this [example](https://github.com/CITGuru/PyInquirer/blob/master/examples/checkbox.py) from their documentation.

Here I will show another style of testing which I call "green-refactor". Sometimes creating a failing test first is quite tedious so I create the feature and then add a test for it. Over time you'll figure out your style of how to do things.

### Green

First we create a new function for generating the questions in the right format

```python
def generate_questions(files):
    questions = [{
        'type': 'checkbox',
        'name': 'files',
        'message': 'What would you like to commit',
        'choices': [{'name': file} for file in files],   
    }]
    return questions
```

For generating our `'choices'` we use Python [List Comprehension](https://www.programiz.com/python-programming/list-comprehension) which is one of my favorite features from the language.

We add the import for `prompt`

```python
from PyInquirer import prompt
```

Note: This might lead to a `pytest` warning complaining that it won't

In our `main` function we slot this in and just print to see if we got the right output.

```python
def main(self):
        print_banner("Git fancy add")
        files = get_files()

        questions = generate_questions(files)
        answers = prompt(questions)
        print(answers['files'])
```

The output now shows that we get the user choices in an array.

```txt
? What would you like to commit  done (2 selections)
['file3.txt', 'requirements.txt']
```

Now to write a test for this. We can put it in the bottom like the other one.

```python
def test_generate_questions():
    files = ["best.rb", "good.kt", "small.py"]
    questions = generate_questions(files)
    assert len(questions) == 1 # one question
    assert questions['type'] == 'checkbox' # has to be a checkbox
    assert len(questions['choices']) == len(questions) # same size as files
```

If we run the test (`$ pytest fgit.py`) we should get everything passing.

### Refactor

Now that we have a test acting as a safety net, we can refactor with confidence. Remembering our difficulties from earlier, we decide to add a `strip()` to each menu option. With luck this shouldn't break everything.

```python
def generate_questions(files):
    questions = [{
        'type': 'checkbox',
        'name': 'files',
        'message': 'What would you like to commit',
        'choices': [{'name': file.strip()} for file in files],   
    }]
    return questions
```

If we run `pytest fgit.py` we're still good.

At this point our full file should be

```python
from pyfiglet import Figlet
from plumbum import cli
from plumbum.cmd import ls

from PyInquirer import prompt

def print_banner(text):
    print(Figlet(font='slant').renderText(text))

def get_files():
    ls_output = ls().strip()
    files = ls_output.split("\n")
    return files

def generate_questions(files):
    questions = [{
        'type': 'checkbox',
        'name': 'files',
        'message': 'What would you like to commit',
        'choices': [{'name': file.strip()} for file in files],   
    }]
    return questions

class FancyGitAdd(cli.Application):
    VERSION = "1.3"

    def main(self):
        print_banner("Git fancy add")
        files = get_files()

        questions = generate_questions(files)
        answers = prompt(questions)
        print(answers['files'])

if __name__ == "__main__":
    FancyGitAdd()

### TESTS

def test_get_files():
    files = get_files()
    assert len(files) == 5

def test_generate_questions():
    files = ["best.rb", "good.kt", "small.py"]
    questions = generate_questions(files)
    assert len(questions) == 1 # one question

    question = questions[0]
    assert question['type'] == 'checkbox' # has to be a checkbox
    assert len(question['choices']) == len(files) # same size as files
```

## Calling Git Add

Now that we have the list of files to add, let's actually pass it to `git`.

Similar to `ls`, we take advantage of `plumbum.cmd`.

```python
from plumbum.cmd import ls, git
```

```python
def main(self):
    print_banner("Git fancy add")
    files = get_files()

    questions = generate_questions(files)
    answers = prompt(questions)
    git('add', answers['files'])
```

And if we run this and check the `git status` output we can see that our program worked.

```bash
$ python3 fgit.py
   _______ __     ____                                    __    __
  / ____(_) /_   / __/___ _____  _______  __   ____ _____/ /___/ /
 / / __/ / __/  / /_/ __ `/ __ \/ ___/ / / /  / __ `/ __  / __  /
/ /_/ / / /_   / __/ /_/ / / / / /__/ /_/ /  / /_/ / /_/ / /_/ /
\____/_/\__/  /_/  \__,_/_/ /_/\___/\__, /   \__,_/\__,_/\__,_/
                                   /____/

? What would you like to commit  [fgit.py]
$ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   fgit.py
```

## Commit flag

Now what if we wanted to let people `git commit` once their job was done as well. They can add `-c`/`--commit` to enable that.

Normally I'd commit something like this (ideally with a more helpful message)

```bash
$ git commit -m "add files"
$
```

Luckily for us, `plumbum` makes adding another flag relatively easy. If we use `cli.Flag` then the result will be attached to `self` and we can use it in our program.

```python
class FancyGitAdd(cli.Application):
    VERSION = "1.3"
    commit = cli.Flag(['c', 'commit'], help="Commits the added files as well")

    def main(self):
        print_banner("Git fancy add")
        files = get_files()

        questions = generate_questions(files)
        answers = prompt(questions)
        git('add', answers['files'])
        if self.commit:
            git('commit', '-m', 'add files')
```

and when we run it we can verify with `git log`

```bash
$ python fgit.py -c
   _______ __     ____                                    __    __
  / ____(_) /_   / __/___ _____  _______  __   ____ _____/ /___/ /
 / / __/ / __/  / /_/ __ `/ __ \/ ___/ / / /  / __ `/ __  / __  /
/ /_/ / / /_   / __/ /_/ / / / / /__/ /_/ /  / /_/ / /_/ / /_/ /
\____/_/\__/  /_/  \__,_/_/ /_/\___/\__, /   \__,_/\__,_/\__,_/
                                   /____/

? What would you like to commit  [fgit.py]
$ git log
commit 7dd8feb673ae8a71f9a6d04ea5604336eda67b56 (HEAD -> main)
Author: Harsh Deep <>
Date:   Tue May 18 21:13:16 2021 -0500

    add files
```

The help output will also show the input for the new option.

```bash
$ python fgit.py --help
fgit.py 1.3

Usage:
    fgit.py [SWITCHES]

Meta-switches:
    -h, --help         Prints this help message and quits
    --help-all         Prints help messages of all sub-commands and quits
    -v, --version      Prints the program's version and quits

Switches:
    -c, --commit       Commits the added files as well

```

## Final Code

```python
from pyfiglet import Figlet
from plumbum import cli
from plumbum.cmd import ls, git

from PyInquirer import prompt

def print_banner(text):
    print(Figlet(font='slant').renderText(text))

def get_files():
    ls_output = ls().strip()
    files = ls_output.split("\n")
    return files

def generate_questions(files):
    questions = [{
        'type': 'checkbox',
        'name': 'files',
        'message': 'What would you like to commit',
        'choices': [{'name': file.strip()} for file in files],   
    }]
    return questions

class FancyGitAdd(cli.Application):
    VERSION = "1.3"
    commit = cli.Flag(['c', 'commit'], help="Commits the added files as well")

    def main(self):
        print_banner("Git fancy add")
        files = get_files()

        questions = generate_questions(files)
        answers = prompt(questions)
        git('add', answers['files'])
        if self.commit:
            git('commit', '-m', 'add files')

if __name__ == "__main__":
    FancyGitAdd()

### TESTS

def test_get_files():
    files = get_files()
    assert len(files) == 5

def test_generate_questions():
    files = ["best.rb", "good.kt", "small.py"]
    questions = generate_questions(files)
    assert len(questions) == 1 # one question

    question = questions[0]
    assert question['type'] == 'checkbox' # has to be a checkbox
    assert len(question['choices']) == len(files) # same size as files
```

Running `$pytest fgit.py` should have all tests passing. (Don't worry about warnings)

## Exercise

* Add a optional command line flag (also called switch) called `-p`/`--push` for running `git push` at the end of the program.

## Learn More

* [Plumbum scripting](https://iscinumpy.gitlab.io/post/plumbum-scripting/) - learn more about the library use to interact with the actual system programs.

* [Building Beautiful Command Line Interfaces with Python](https://codeburst.io/building-beautiful-command-line-interfaces-with-python-26c7e1bb54df) - a good introduction to pretty command line libraries. Examples included!

* [Python Command Line Apps](https://www.davidfischer.name/2017/01/python-command-line-apps/) - some theory on the aspects of command line apps, as well as library recommendations.

## Ideas

Feel free to come up with anything you want as long as it's cli related. Here are some ideas to help you get started, but feel free to come up with more. Don't worry if it's already been done or if someone else is doing it. The point is learning and fun. :)

* Take some application you commonly use daily and try to make a command line version: gratitude journals, weather updates or getting scores from a sports team of your choice.

* Is there some commmand line application you found annoying or hard to use? How would you improve it?

* Maybe the chatbot from last week could also be available in command line form. Could you spice it up with fancy menu selectors or ASCII displays?

* Maybe you can use this to automate some workflow task you have by combining some steps together with `plumbum`. One of the greatest things about command lines is that you can use each program as a modular piece to compose very powerful utilities.

## Requirements

* Can run from your command line.

* Have a version number.

* It has to have a have a working `-h/--help` option.

* It has to accept at least one custom flag.

* There should be at least two test cases.

* Has to have a `README` where you explain how it works along with pictures/animations/vidoes.

* Fix as many `pylint` errors as you can. Some errors are weird or might take a long time to fix but the rest you definitiely should.

* Has to use a Open Source license via a `LICENSE` file

Contributors: Harsh, Maaheen
