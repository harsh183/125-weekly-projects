---
layout: post
title: Fancy command line interface
date: 2020-06-08
comments: true
external-url:
categories: Python
---

You might have seen programmers everywhere using the command line for all sorts of daily tasks. It looks kind of unfriendly and complicated, right?

How about we make things a little prettier and easier for people to use?

```python
print("Hello command line")
```

Hosted by: Harsh Deep

## Motivation

Here's an 18 minute audio recording made specially for this summer session by [Donovan Keme](https://github.com/digitalextremist), my mentor last summer who broadened my perspective on tech entirely. His open source Ruby work has been part of almost [450 million downloads](https://rubygems.org/profiles/digitalextremist), and he's very involved with the community.

This is a more somber and serious recording instead of the typical emotional pep talk, but it's important to consider in your journey after several months about learning about technology. At this point, it's the right time to start thinking about what role technology plays in the world and what purpose you want to achieve with technology. 

[Recording link](https://extremist.digital/audio/126-m20210504083039-5tp5-harsh.mp3
)

Don't worry if you don't know what your purpose is right now. What this means can be different for everyone. Over the next few months, start to reflect and chart out your goals of what you want to do and the steps you want to take from there. Feel free to message any of the staff or create a forum post if you want to talk about it too.

## Getting Ready 

1. Learn a bit of git on the commmand line. You can use any intro tutorial, but [this web browser one](https://learngitbranching.js.org/) looks good.

2. Go over the basics of test driven development with `pytest` in this tutorial on [the site](/testing101). Code along everything just to get an idea of why we test and how to create your workflow around tests. While I don't want all projects to have extensive tests (although it is a good habit), having even just 3-5 tests makes a huge difference. 

## Workshop

Our goal is to make a fancy git add command line application that has a nice interactive interface. We display a list of files that can be added and then have the user select. Then we provide them an option to commit the file as well.

Note: I've done this on an Ubuntu system. Your progress won't be drastically different but you may need to adjust depending on how your OS does things. Feel free to post forum questions in case there are any problems.

### Libraries

Create a file called `requirements.txt` and fill it with this. This is a common convention in Python projects for listing all the libraries required. 

```txt
pyinquirer
pyfiglet
plumbum
pylint
pytest
```

Once you've saved this file, to install you just have to run (if you use `python3` to excute commands this will be `pip3`).
```bash
$ pip install -r requirements.txt
``` 

The `-r` flag tells `pip` to look at `requirements.txt` and install everything in it.

Let me explain how we're using each library.

* `pyinquirer` give us fancy interactive menu interfaces
* `pyfiglet` gives us ASCII art displays
* `plumbum` gives us a way of accepting input, displaying help information and calling existing system commands
* `pylint` is for style checking
* `pytest` is for simple testing

### Get started

Create a file called `fgit.py`.

We use `cli` from the `plumbum` library to create the base template for our command line application. 

```python
from plumbum import cli

class FancyGitAdd(cli.application):
    def main(self):
        print("Welcome to Fancy Git Add!")

if __name__ == "__main__":
    FancyGitAdd()

```

Now if we run this we get our starter message.

```
$ python fgit.py
Welcome to Fancy Git Add!
```

The reason we have a `__name__ == "__main__"` condition is because our program will be run in different ways. When running the program normally through python the condition will be true and the stuff inside will run, but in other cases it won't.

Basically, without that, our tests will not work and give a screenful of nasty errors. We haven't written any tests yet but just to sanity check.

```
$ pytest fgit.py
```

Which will tell us everything is good and no test ran.

### Provide help

Almost every major command line program lets you ask for help using `-h` or `--help`. This is good because things can be quite confusing otherwise. Writing good help messages for users is _highly reccomended_.

Lets see what we get out of the box thanks to `plumbum`.

```
$ python fgit.py --help
Usage:
    fgit.py [SWITCHES]

Meta-switches:
    -h, --help         Prints this help message and quits
    --help-all         Prints help messages of all sub-commands and quits
    -v, --version      Prints the program's version and quits
```

Not a bad start. Now the first thing we can do is give our a version number. In a real program we will change the version number as we add new changes so that people know when to update.

```python
from plumbum import cli

class FancyGitAdd(cli.Application):
    VERSION = "1.3"

    def main(self):
        print("Welcome to Fancy Git Add")

if __name__ == "__main__": 
    FancyGitAdd()  
```

This gets our version number display working nicely: 
```
$ python fgit.py --version
fgit.py 1.3
$ python fgit.py -h
fgit.py 1.3

Usage:
    fgit.py [SWITCHES]

Meta-switches:
    -h, --help         Prints this help message and quits
    --help-all         Prints help messages of all sub-commands and quits
    -v, --version      Prints the program's version and quits
```

Note: One character flags have a single dash `-` and are one letter long to be short. The longer flag is usually a word or phrase and has two dashes `-`.

## Improve the display

The text output from `print` does look nice but we want those fancy ASCII art displays. For this we're going to use `pyfiglet`

```python
from pyfiglet import Figlet

def print_banner(text):
    print(Figlet(font='slant').renderText(text))

class FancyGitAdd(cli.Application):
    VERSION = "1.3"

    def main(self):
        print_banner("Git fancy add")

if __name__ == "__main__":
    FancyGitAdd()
```

We create a function `print_banner(text)` to print our ASCII banner on our screen based on the [pyfiglet documentation](https://github.com/pwaller/pyfiglet). 

In general, it's a good practice to have extracted out functions (like this one) so that we can create more layers of abstraction for readability or testing. The command line application doesn't need to bother itself with the details of _how_ we print a banner, just that it gets printed.

## Collecting a list of files

One of the most common commands we ever use in the command line is called `ls` to list all files in the current folder.

Let's try it out to get a list of 5 items I have (your system might vary but adjust accordingly)
```
$ ls
__pycache__  fgit.py  file3.txt  requirements.txt  test_folder
```

Lets use this as a chance to show off red-green-refactor with `pytest`.

### Red

For testing around I'm creating a folder called `test_folder` with two files `file1.txt` and `file2.txt`. I'm also adding a `file3.txt` outside the folder. You can create whatever sample files you like. 

If you want to do the same thing as I am doing using `mkdir` (create directory), `cd` (change directory), and `touch` (create file or update last edited) 

```
$ mkdir test_folder
$ touch test_folder/file1.txt test_folder/file2.txt file3.txt
```

The end result looks something like this: (generated via a command line program called [tree](https://linux.die.net/man/1/tree)).

```
$ tree
.
├── __pycache__
│   └── fgit.cpython-38-pytest-6.2.4.pyc
├── fgit.py
├── file3.txt
├── requirements.txt
└── test_folder
    ├── file1.txt
    └── file2.txt
```

Now lets come up with a function `get_files()` which will return a `List` of the files in the given directory. We write a stub for that function and write a test `test_get_files()` to test it.

```python
from pyfiglet import Figlet
from plumbum import cli

def print_banner(text):
    print(Figlet(font='slant').renderText(text))

def get_files():
    return [] # empty list for now

class FancyGitAdd(cli.Application):
    VERSION = "1.3"
    # commit = cli.Flag(['c', 'commit'], help="Commits the added files as well")

    def main(self):
        print_banner("Git fancy add")
        files = get_files()
        # if (self.commit):
            # print("I see you also want to commit")

if __name__ == "__main__":
    FancyGitAdd()

### TESTS

def test_get_files():
    files = get_files()
    assert len(files) == 5
```

Which if we now test 
```
$ pytest fgit.py
    def test_get_files():
        files = get_files()
>       assert len(files) == 5
E       assert 0 == 5
E        +  where 0 = len([])

fgit.py:39: AssertionError
```

Which is what we expect. One we implement the feature this test will become green.

### Green

Using `plumbum.cmd` we can import commands from the command line and use it within python. This import lets us import basically any existing system command so that we can use it in our program.

The first step of understanding how to process output of a command line program is just inspecting it. Here we just `print` it with a `"start"` and `"end"` to understand how the string processing is working.

```python
from pyfiglet import Figlet
from plumbum import cli
from plumbum.cmd import ls

[...]

def get_files():
    ls_output = ls()
    print("start", ls_output, "end")
    return [] # empty list for now

[...]

def test_get_files():
    files = get_files()
    assert len(files) == 5
```

and the output snippet we get is 
```
start __pycache__
fgit.py
file3.txt
requirements.txt
test_folder
 end
```

Looks like we have to split by line and take care of some whitespace around the start and end. We can use a combo of `strip` (strip is quite common to use when dealing with string output) and `split`. Our final funcion will be

```python
def get_files():
    ls_output = ls().strip()
    print("start", ls_output, "end")
    files = ls_output.split("\n")
    return files

[...]

def test_get_files():
    files = get_files()
    assert len(files) == 5
```

Now if we run this with `pytest` it will give green.

```
$ pytest fgit.py
```

### Refactor

One we have a working test for a feature, we can refactor (improve) our code with confidence. The test cases act as a safety net.

If we run our program 
```
$ python fgit.py
   _______ __     ____                                    __    __
  / ____(_) /_   / __/___ _____  _______  __   ____ _____/ /___/ /
 / / __/ / __/  / /_/ __ `/ __ \/ ___/ / / /  / __ `/ __  / __  /
/ /_/ / / /_   / __/ /_/ / / / / /__/ /_/ /  / /_/ / /_/ / /_/ /
\____/_/\__/  /_/  \__,_/_/ /_/\___/\__, /   \__,_/\__,_/\__,_/
                                   /____/

start __pycache__
fgit.py
file3.txt
requirements.txt
test_folder end
```

The debug output still appears. A refactor step would be removing that and just checking if the tests work again.

We update `get_files()`

```python
def get_files():
    ls_output = ls().strip()
    files = ls_output.split("\n")
    return files
```

and running tests should still give green

```
$ pytest fgit.py
```.

Our full code at this stage should be 

```python
from pyfiglet import Figlet
from plumbum import cli
from plumbum.cmd import ls

def print_banner(text):
    print(Figlet(font='slant').renderText(text))

def get_files():
    ls_output = ls().strip()
    files = ls_output.split("\n")
    return files

class FancyGitAdd(cli.Application):
    VERSION = "1.3"
    # commit = cli.Flag(['c', 'commit'], help="Commits the added files as well")

    def main(self):
        print_banner("Git fancy add")
        files = get_files()
        # if (self.commit):
            # print("I see you also want to commit")

if __name__ == "__main__":
    FancyGitAdd()

def test_get_files():
    files = get_files()
    assert len(files) == 5
```

Note: This is a simple test for teaching reasons. In real life you should write tests more robust since this can easily break if I have one more or one less file.

## Fancy Menu Selectors

### Green

### Refactor

## Calling Git Add

* now display it in a command line GUI checkbox format 
* once people hit enter give that list to git add 
* have optional command line argument for commit `-c`

## Exercise

* Add a optional command line argument called `-p` for running `git push` at the end of the program.

## Learn More

* [Plumbum scripting](https://iscinumpy.gitlab.io/post/plumbum-scripting/) - learn more about the library we'll to interact with the actual system programs.

* [Building Beautiful Command Line Interfaces with Python](https://codeburst.io/building-beautiful-command-line-interfaces-with-python-26c7e1bb54df) - a good introduction to pretty command line interfaces, with some examples!

* [Python Command Line Apps](https://www.davidfischer.name/2017/01/python-command-line-apps/) - some theory on the aspects of command line apps, as well as library recommendations.

## Ideas

Feel free to come up with anything you want as long as it's chatbot related. Here are some ideas to help you get started, but feel free to come up with more. Don't worry if it's already been done or if someone else is doing it. The point is learning and fun. :)

* Is there some commmand line application you found annoying or hard to use? How would you improve it?

* Maybe the chatbot from last week could also be available in command line form. Could you spice it up with fancy menu selectors or ASCII displays?

* Maybe you can use this to automate some workflow task you have by combining some steps together with `plumbum`. One of the greatest things about command lines is that you can use each program as a modular piece on to the next.

## Requirements

* It has to be a command line application.

* Has to use a Open Source license via a `LICENSE` file