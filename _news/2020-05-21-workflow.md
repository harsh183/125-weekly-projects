---
layout: post
title: Workflow
date: 2020-05-21
comments: true
external-url:
categories: Info
---

<!-- markdownlint-disable MD004 MD009 MD014 MD024 MD040 -->

Time to plan and work!

By now I hope you have at least a starter idea of what you want to do. Your start goals and end goals will differ as you go along so now is the time to figure out the process. If you don't have an idea yet, read our [Idea guide](/ideas) first.

These are not clear well-defined steps and you'll find you going back and forth in a real workflow quite a lot. This is a hard skill to learn but practice will make yourself better and you have decades to get good at this. This is all advice, and over time you'll figure out your own rules of working that will be quite different from mine or anyone else's.

## Start defining the idea 

Ideas are fun because they're fun to play with in your head. It's easy to get lost in the possibilities and all the cool things you can achieve.

Our brain is good at fooling itself, and if you keep things in your head then you will not realize that your idea is very incomplete. It doesn't matter where you take notes (notebooks, documents, mindmaps, Github issues, a kanban board, etc.) but start fleshing out the idea. At first just brain dump but then start thinking in terms of features, [User Stories](https://www.visual-paradigm.com/guide/agile-software-development/what-is-user-story/), roadblocks, potential challenges, technical tools. 

At first, you'll start putting things up quick, but then the pace slows down as you realize you didn't have as much in your head. Keep working out the details, searching up things (and noting down what you want), and organizing your initial idea.

This phase doesn't have to be too long, can be 15 minutes, can be an hour, or at best a day. It's important to reflect on this a little but also don't get stuck in "planning hell". At that point leave your planning work at a point where you can come back and expand on it.

## Figure out what is important

This part is hard, and even very experienced people get this wrong all the time. It's easy to come up with a neverending list of features and requirements, but doing them all will take you forever and you will not finish. Even if you somehow finish, your result might be overly complicated or hard to use. Being picky about what you want to do not only makes your life easier, but it makes your actual users happier, win-win.

The standard advice is to figure out what is needed for an **M.V.P** (Minimum Viable Product). What is an almost embarrassing early version of what you want to make that contains just the _bare minimum_ of your idea? From your list that you made already try to pick out things that would hit these criteria. Learning how to do this will take a few times, so don't worry if you don't completely hit this right. Usually experience helps. The rule of thumb for a feature X think back to your [idea](/ideas) and if you can remove feature X and still have your software hit your idea it's good.

## Create a rough ranking of what to do and work in that order

Your primary goal is hitting an MVP. It's starting simple and working in some order of your M.V.P. list that you figured out. As you work along you might realize you don't need feature X, feature Y is more important than you initially thought, or maybe you figured out an even cooler idea. At every step of the way keep your users in mind, if your ideal user is **you** then getting that instant feedback is easy. If you feel embarrassed and underwhelmed by your MVP but it _kinda_ works with your problem statement you succeeded.

Once you have a basic-ish MVP then you can start picking more things to add to make it nicer. The goal now is incremental development. Do a task one at a time(Add a feature, improve a look, create some documentation, fix some bug, automate) and then make sure everything is working fine. Repeat. If you have test cases (we'll cover a bit of `pytest` and `mocha`) this process becomes faster.

As you work along, you'll also unlock more ideas and start to understand some of the technical hurdles that you're dealing with. Keep adding them to your initial list from the first step and expanding on. With Github issues, this is easy to do since you can just keep adding issues. This kind of list also allows other contributors to come in and identify parts they can start helping with.

Your list will always be larger than the things you have, and a lot of features will never get implemented at all. This is natural and part of almost every real-life project (unless it's extremely narrowly defined). Even the [125s-weekly-projects](https://github.com/harsh183/125-weekly-projects/issues) GitHub repo that the site is running from will always have more issues to solve. This is a good thing because it lets us pick and choose how we're moving forward. **Most software is never complete.**

## False Starts and Mistakes

You will have false starts early on, and make bad decisions at first as you try to understand that problem. This is okay, normal, and honestly part of the process. Feel free to restart a few times if it feels real off. Be careful not to get in a loop of restarting since any meh foundation is a better starting point than none at all. The rule of thumb is that your 4th restart should be your last one till you get a working MVP. Make sure to save all your planning and code work somewhere so that with each restart you have something more to work from. No matter how bad it is, don't delete it (you can archive it somewhere out of sight if you want).

It is also natural to make mistakes, ruin something, or waste a few hours in a feature that you realize is hopelessly complicated. This is okay, normal, and part of the process of working as well. Learning software like `git` is a big help since it is designed around this. `git` is basically like a time travel machine of your project, each commit is like marking a point your time travel machine can come back to. `git` even supports creating multiple parallel universes of your code via `branches` and this is a very useful feature in practice when making real software.

## Have fun

Seriously don't ignore this. Doing projects on your own should not be a chore or something you're doing for the sake of someone else (if you're making software for the sake of someone else, at least make sure to get paid a competitive rate for it). Different people are drawn into computer science for different reasons, and everyone will like different parts of the process. The goal is to also start figuring out what you like, and what you don't.

Good luck! 

## Good Advice from others

[https://peterlunch.com/how-to-plan-and-build-a-programming-project/](https://peterlunch.com/how-to-plan-and-build-a-programming-project/) - Peter Lynch. Honestly, this is a great blog post and one of the big things that inspired this entire summer initiative. I shared the idea with them as well and I got nice validation. Instead of Trello like he suggests you can also check out Github Projects that are built into every repository.
