---
layout: post
title: Workflow
date: 2020-05-21
comments: true
external-url:
tag: Info
toc: true
---

<!-- markdownlint-disable MD004 MD009 MD014 MD024 MD040 -->

Time to plan and work!

By now, I hope you have at least a starter idea of what you want to do. Your goals will differ as you go along, so now is the time to figure out your process. If you don't have an idea yet, read our [idea guide](/ideas) first.

These are not clearly well-defined steps, and you'll find you going back and forth in a real workflow quite a lot. Finding a workflow is a hard skill to learn, but practice makes better, as always. Over time, you'll figure out your own rules of working that may be be different from mine or anyone else's.

But for now, here's a sample workflow to get you started.

## Start defining the idea 

Ideas are fun because they're fun to play with in your head. It's easy to get lost in the possibilities and all the cool things you can achieve.

However, the brain is incredibly good at fooling itself, and if you keep your ideas in your head, then you won't realize how incomplete the idea is. It doesn't matter where you take notes (notebooks, documents, mindmaps, Github issues, a kanban board, etc.), but you should start fleshing out the idea. At first, just brain dump. Then, start thinking in terms of features, [User Stories](https://www.visual-paradigm.com/guide/agile-software-development/what-is-user-story/), roadblocks, potential challenges, and technical tools.

At first, you'll start writing things down quickly, but then the pace will slow down as you realize that you didn't have as complete an idea as you thought you did. Keep working out the details, searching up things (and noting down what you want), and organizing your initial idea.

This phase doesn't have to be too long. It can be 15 minutes, an hour, or at longest a day. It's important to reflect on this a little, but also don't get stuck in "planning hell". At that point, just leave your planning work at a point where you can come back and expand on it later.

## Figure out what's important

This part is hard, and even very experienced people get this wrong all the time. It's easy to come up with a neverending list of features and requirements, but doing them all will take you forever and you will not finish. Even if you do somehow finish, your result might be overly complicated or hard to use. Being picky about what you want not only makes your life easier, but it also makes your actual users happier. It's a win-win.

The standard advice is to figure out what is needed for an **M.V.P** (Minimum Viable Product). What's the _bare minimum_ that you can do for this project? What's the (perhaps embarrassingly) early version of your idea? From the list that you made already, try to pick out the features that hit these criteria. Learning how to do this will take some practice, so don't worry if you can't do it perfectly. The rule of thumb for a feature X: think back to your [idea](/ideas), and if you can remove feature X and still have your software hit your idea, then it's not part of the M.V.P.

## Create a rough ranking of what to do and work in that order

Your primary goal is hitting an MVP. You need to start simple and work in the order of the M.V.P. list that you figured out. As you work along, you might realize that you don't need feature X, or that feature Y is more important than you initially thought, or maybe you figured out an even cooler idea. At every step of the way, keep your users in mind. If your ideal user is **you**, then getting that instant feedback is easy. If you feel embarrassed and underwhelmed by your MVP but it _kinda_ works with your problem statement, you've succeeded.

Once you've fulfilled your MVP, you can start picking more things to add to make it nicer. The goal now is incremental development. Complete each task one at a time (Add a feature, improve a look, create some documentation, fix some bug, automate), and then make sure  that everything is working fine. Rinse and repeat. If you have test cases (we'll cover a bit of `pytest` and `mocha`), this process can become faster and easier.

As you work along, you'll unlock more ideas and start to understand some of the technical hurdles that you're dealing with. Keep adding them to your initial list and expanding on. One way you can do this is with Github issues, which make it easy because you can just keep adding issues for things you need. This kind of list also allows other contributors to potentially come in and identify parts that they can start helping with.

Your list will almost always be larger than the program you have, and a lot of features will never be implemented at all. This is natural and part of almost every real-life project (unless it's extremely narrowly defined). Even the [125-weekly-projects](https://github.com/harsh183/125-weekly-projects/issues) GitHub repo that the site is running from will always have more issues to solve. This is a good thing because it lets us pick and choose how we're moving forward. **Most software is never complete.**

## False Starts and Mistakes

You will have false starts early on, and you will make bad decisions at first. This is okay, normal, and honestly part of the process. Feel free to restart a few times if it feels off. Still, be careful not to get in a loop of restarting, since any "meh" foundation is a better starting point than no foundation at all. The rule of thumb is that your fourth restart should be your last one until you get a working MVP. Make sure to save all your planning and code work somewhere so that with each restart, you have a more solid base to work from. No matter how bad it is, don't delete it (you can archive it somewhere out of sight if you want).

It is also natural to make mistakes, ruin something, or waste a few hours with a feature that you then realize is hopelessly complicated. This is okay, normal, and part of the process of working as well. Learning software like `git` is a big help, since it's designed around this. `git` is basically like a time travel machine of your project. Each commit is like marking a point that your time travel machine can come back to. `git` even supports creating multiple parallel universes of your code via `branches`, which is a very useful feature in practice when making real software.

## Have fun

Seriously, don't ignore this. Doing projects on your own should not be a chore or something you're doing for the sake of someone else (if you're making software for the sake of someone else, at least make sure to get paid a competitive rate for it). Different people are drawn into computer science for different reasons, and everyone will like different parts of the process. Part of your goal is to start figuring out what you like and what you don't.

Good luck! 

## Good Advice from others

[https://peterlunch.com/how-to-plan-and-build-a-programming-project/](https://peterlunch.com/how-to-plan-and-build-a-programming-project/) - Peter Lynch. Honestly, this is a great blog post and one of the big things that inspired this entire summer initiative. I shared the idea with them as well, and I got nice validation. Instead of Trello like he suggests, you can also check out the Github Projects that are built into every repository.

Contributors: Harsh, Drshika, Maaheen
